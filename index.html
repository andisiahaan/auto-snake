<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#A020F0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="description" content="Snake Pro Game">
    <link rel="manifest" href="manifest.json">
    <title>Snake Pro</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=JetBrains+Mono:wght@400;700&display=swap');

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: #050508;
            color: #fff;
            font-family: 'JetBrains Mono', 'Consolas', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            height: 100dvh;
            overflow: hidden;
            cursor: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-wrapper {
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            box-shadow:
                0 0 60px rgba(160, 32, 240, 0.15),
                0 0 120px rgba(160, 32, 240, 0.05),
                inset 0 0 60px rgba(0,0,0,0.5);
            border: 1px solid rgba(160, 32, 240, 0.2);
        }

        canvas {
            display: block;
            background-color: #0a0a0f;
        }

        /* HUD - Top Bar */
        #hud {
            position: absolute;
            top: 0; left: 0; right: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            z-index: 10;
            background: linear-gradient(to bottom, rgba(0,0,0,0.7) 0%, transparent 100%);
            font-family: 'Orbitron', monospace;
        }

        .hud-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .hud-label {
            font-size: 0.5rem;
            color: rgba(255,255,255,0.4);
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .hud-value {
            font-size: 0.9rem;
            font-weight: 900;
            color: #fff;
            text-shadow: 0 0 10px rgba(160, 32, 240, 0.6);
        }

        #score-val { color: #A020F0; }
        #high-score-val { color: #FFD700; }
        #length-val { color: #00FFCC; }

        /* Energy Bar */
        .energy-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .energy-bar {
            width: 60px;
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.05);
        }

        #energy-fill {
            height: 100%;
            background: linear-gradient(90deg, #00FF88, #00FFCC);
            width: 100%;
            transition: width 0.1s linear;
            border-radius: 3px;
            box-shadow: 0 0 6px rgba(0, 255, 136, 0.4);
        }

        /* Combo Display */
        #combo-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 15;
            pointer-events: none;
        }

        .combo-text {
            position: absolute;
            font-family: 'Orbitron', monospace;
            font-weight: 900;
            white-space: nowrap;
            animation: comboFloat 1s ease-out forwards;
            pointer-events: none;
        }

        @keyframes comboFloat {
            0% { opacity: 1; transform: translate(-50%, 0) scale(0.5); }
            30% { opacity: 1; transform: translate(-50%, -20px) scale(1.2); }
            100% { opacity: 0; transform: translate(-50%, -80px) scale(0.8); }
        }

        /* Fake WASD Keys */
        #wasd-container {
            position: absolute;
            bottom: 15px;
            right: 15px;
            z-index: 10;
            display: grid;
            grid-template-areas:
                ". w ."
                "a s d";
            grid-template-columns: repeat(3, 32px);
            grid-template-rows: repeat(2, 32px);
            gap: 3px;
            opacity: 0.5;
        }

        .wasd-key {
            width: 32px;
            height: 32px;
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Orbitron', monospace;
            font-size: 0.6rem;
            font-weight: 700;
            color: rgba(255,255,255,0.3);
            transition: all 0.08s ease;
        }

        .wasd-key.active {
            background: rgba(160, 32, 240, 0.4);
            border-color: rgba(160, 32, 240, 0.8);
            color: #fff;
            box-shadow: 0 0 15px rgba(160, 32, 240, 0.4);
            transform: scale(0.92);
        }

        #key-w { grid-area: w; }
        #key-a { grid-area: a; }
        #key-s { grid-area: s; }
        #key-d { grid-area: d; }

        /* Game Over Overlay */
        #ui-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(5, 5, 8, 0.92);
            z-index: 20;
            border-radius: 12px;
            transition: opacity 0.4s ease;
            text-align: center;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
        }

        #overlay-title {
            font-family: 'Orbitron', monospace;
            font-weight: 900;
            font-size: 1.8rem;
            letter-spacing: 3px;
            color: #fff;
            text-shadow: 0 0 30px rgba(160, 32, 240, 0.8);
            margin-bottom: 5px;
        }

        #overlay-sub {
            color: rgba(255,255,255,0.4);
            font-size: 0.75rem;
            margin-bottom: 20px;
            line-height: 1.6;
            letter-spacing: 1px;
        }

        #start-btn {
            background: transparent;
            color: #A020F0;
            border: 2px solid #A020F0;
            padding: 14px 50px;
            font-size: 0.85rem;
            border-radius: 50px;
            cursor: pointer;
            font-family: 'Orbitron', monospace;
            font-weight: 900;
            letter-spacing: 4px;
            text-transform: uppercase;
            transition: all 0.3s ease;
            box-shadow: 0 0 30px rgba(160, 32, 240, 0.2);
            position: relative;
            overflow: hidden;
        }

        #start-btn:hover, #start-btn:active {
            background: rgba(160, 32, 240, 0.15);
            box-shadow: 0 0 50px rgba(160, 32, 240, 0.4);
            transform: scale(1.05);
        }

        /* Stats Panel */
        #stats-panel {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 10;
            font-size: 0.5rem;
            color: rgba(255,255,255,0.2);
            letter-spacing: 1px;
            font-family: 'JetBrains Mono', monospace;
            line-height: 1.5;
        }

        /* Floating particles layer */
        #particle-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        /* Screen shake */
        .shake {
            animation: screenShake 0.3s ease;
        }

        @keyframes screenShake {
            0%, 100% { transform: translate(0, 0); }
            20% { transform: translate(-4px, 2px); }
            40% { transform: translate(4px, -2px); }
            60% { transform: translate(-2px, 4px); }
            80% { transform: translate(2px, -4px); }
        }

        /* Pulse animation for food */
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.15); }
        }

        /* Session Summary in overlay */
        .session-stats {
            display: flex;
            gap: 20px;
            margin-top: 12px;
            font-size: 0.65rem;
            color: rgba(255,255,255,0.3);
        }

        .session-stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .session-stat-value {
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            font-size: 1rem;
            color: rgba(255,255,255,0.6);
        }
    </style>
</head>
<body>

    <div id="game-wrapper">
        <!-- HUD -->
        <div id="hud">
            <div class="hud-item">
                <span class="hud-label">Score</span>
                <span class="hud-value" id="score-val">0</span>
            </div>
            <div class="energy-container">
                <span class="hud-label">Energy</span>
                <div class="energy-bar"><div id="energy-fill"></div></div>
            </div>
            <div class="hud-item">
                <span class="hud-label">Length</span>
                <span class="hud-value" id="length-val">4</span>
            </div>
            <div class="hud-item">
                <span class="hud-label">Best</span>
                <span class="hud-value" id="high-score-val">0</span>
            </div>
        </div>

        <!-- Game Canvas -->
        <canvas id="gameCanvas"></canvas>

        <!-- Combo display -->
        <div id="combo-display"></div>

        <!-- Particle layer -->
        <canvas id="particle-layer"></canvas>

        <!-- Fake WASD -->
        <div id="wasd-container">
            <div class="wasd-key" id="key-w">W</div>
            <div class="wasd-key" id="key-a">A</div>
            <div class="wasd-key" id="key-s">S</div>
            <div class="wasd-key" id="key-d">D</div>
        </div>

        <!-- Stats -->
        <div id="stats-panel">
            <div>GAMES: <span id="stat-games">0</span></div>
            <div>EATEN: <span id="stat-eaten">0</span></div>
            <div>MAX: <span id="stat-max">0</span></div>
        </div>

        <!-- Overlay -->
        <div id="ui-overlay">
            <div id="overlay-title">SNAKE PRO</div>
            <p id="overlay-sub">TAP TO PLAY</p>
            <button id="start-btn">START</button>
        </div>
    </div>

<script>
    /**
     * ============================================
     *  SNAKE PRO â€” Auto-play AI with Pro Visuals
     *  Designed for TikTok Live Streaming
     * ============================================
     */

    // === DOM REFS ===
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const pCanvas = document.getElementById('particle-layer');
    const pCtx = pCanvas.getContext('2d');
    const uiOverlay = document.getElementById('ui-overlay');
    const startBtn = document.getElementById('start-btn');
    const scoreVal = document.getElementById('score-val');
    const highScoreVal = document.getElementById('high-score-val');
    const lengthVal = document.getElementById('length-val');
    const energyFill = document.getElementById('energy-fill');
    const overlayTitle = document.getElementById('overlay-title');
    const overlaySub = document.getElementById('overlay-sub');
    const comboDisplay = document.getElementById('combo-display');
    const gameWrapper = document.getElementById('game-wrapper');
    const statGames = document.getElementById('stat-games');
    const statEaten = document.getElementById('stat-eaten');
    const statMax = document.getElementById('stat-max');

    // WASD Keys
    const keyW = document.getElementById('key-w');
    const keyA = document.getElementById('key-a');
    const keyS = document.getElementById('key-s');
    const keyD = document.getElementById('key-d');

    // === CONFIG ===
    const COLS = 22;
    const ROWS = 28; // Taller for portrait mode
    let BLOCK_SIZE = 18;

    // Speed Config
    const BASE_SPEED = 65;     // Starting speed (ms)
    const MIN_SPEED = 35;      // Max speed when long
    const SPEED_STEP = 0.5;    // ms faster per food eaten

    // Colors
    const C_BG = '#0a0a0f';
    const C_GRID = '#0f0f18';
    const C_HEAD = '#FFFFFF';
    const C_BODY_START = '#C840FF'; // Head-end purple
    const C_BODY_END = '#3D0066';   // Tail-end purple
    const C_TAIL = '#FF0055';
    const C_FOOD_NORMAL = '#00FFCC';
    const C_FOOD_BONUS = '#FFD700';

    // === GAME STATE ===
    let snake = [];
    let foods = [];
    let score = 0;
    let highScore = parseInt(localStorage.getItem('snakeHighScore') || '0');
    let gameInterval = null;
    let isRunning = false;
    let currentSpeed = BASE_SPEED;
    let lastDirection = { x: 1, y: 0 };

    // Starvation
    let movesSinceEat = 0;
    const MAX_MOVES_WITHOUT_EAT = 600;

    // Combo System
    let combo = 0;
    let comboTimer = null;
    const COMBO_TIMEOUT = 3000; // 3s to keep combo

    // Session Stats
    let totalGames = 0;
    let totalEaten = 0;
    let maxLength = 0;

    // Particles
    let particles = [];

    // Trail History (for glow trail)
    let trailHistory = [];
    const MAX_TRAIL = 15;

    // === PWA REGISTRATION ===
    if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('sw.js').catch(() => {});
    }

    // === RESPONSIVE ===
    function resizeCanvas() {
        const maxWidth = Math.min(window.innerWidth - 10, 440);
        const maxHeight = window.innerHeight - 10;
        BLOCK_SIZE = Math.min(
            Math.floor(maxWidth / COLS),
            Math.floor(maxHeight / ROWS)
        );
        BLOCK_SIZE = Math.max(BLOCK_SIZE, 10);
        canvas.width = BLOCK_SIZE * COLS;
        canvas.height = BLOCK_SIZE * ROWS;
        pCanvas.width = canvas.width;
        pCanvas.height = canvas.height;
        if (!isRunning) render();
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    highScoreVal.innerText = highScore;

    // === PATHFINDING (BFS) ===
    function isValid(x, y) {
        return x >= 0 && x < COLS && y >= 0 && y < ROWS;
    }

    function isCollision(x, y, snakeArr) {
        for (let i = 0; i < snakeArr.length - 1; i++) {
            if (x === snakeArr[i].x && y === snakeArr[i].y) return true;
        }
        return false;
    }

    function getPathBFS(start, target, currentSnake) {
        let queue = [start];
        let cameFrom = new Map();
        let visited = new Set();
        let startKey = `${start.x},${start.y}`;
        visited.add(startKey);
        cameFrom.set(startKey, null);
        let found = false;

        while (queue.length > 0) {
            let current = queue.shift();
            if (current.x === target.x && current.y === target.y) {
                found = true;
                break;
            }
            const dirs = [
                { x: 0, y: -1 }, { x: 0, y: 1 },
                { x: -1, y: 0 }, { x: 1, y: 0 }
            ].sort(() => Math.random() - 0.5);

            for (let dir of dirs) {
                let nx = current.x + dir.x;
                let ny = current.y + dir.y;
                let nk = `${nx},${ny}`;
                if (isValid(nx, ny) && !visited.has(nk)) {
                    if (!isCollision(nx, ny, currentSnake)) {
                        visited.add(nk);
                        cameFrom.set(nk, current);
                        queue.push({ x: nx, y: ny });
                    }
                }
            }
        }
        if (!found) return null;
        let path = [];
        let curr = target;
        while (curr) {
            path.push(curr);
            curr = cameFrom.get(`${curr.x},${curr.y}`);
        }
        path.reverse();
        path.shift();
        return path;
    }

    function simulateMove(currentSnake, pathSteps) {
        let ns = JSON.parse(JSON.stringify(currentSnake));
        for (let step of pathSteps) ns.unshift(step);
        while (ns.length > currentSnake.length + 1) ns.pop();
        return ns;
    }

    // === AI BRAIN ===
    function decideNextMove() {
        const head = snake[0];
        const tail = snake[snake.length - 1];

        // Find closest food
        let targetFood = foods[0];
        let minDist = 9999;
        for (let f of foods) {
            let d = Math.abs(head.x - f.x) + Math.abs(head.y - f.y);
            if (d < minDist) {
                minDist = d;
                targetFood = f;
            }
        }

        // STRATEGY 1: Eat safely
        let pathToFood = getPathBFS(head, targetFood, snake);
        if (pathToFood && pathToFood.length > 0) {
            let virtualSnake = simulateMove(snake, pathToFood);
            let vHead = virtualSnake[0];
            let vTail = virtualSnake[virtualSnake.length - 1];
            let escapePath = getPathBFS(vHead, vTail, virtualSnake);
            if (escapePath) return pathToFood[0];
        }

        // STRATEGY 2: Stall â€” chase tail
        let bestStallMove = null;
        let maxDistToTail = -1;
        const dirs = [
            { x: 0, y: -1 }, { x: 0, y: 1 },
            { x: -1, y: 0 }, { x: 1, y: 0 }
        ].sort(() => Math.random() - 0.5);

        for (let dir of dirs) {
            let nx = head.x + dir.x;
            let ny = head.y + dir.y;
            if (isValid(nx, ny) && !isCollision(nx, ny, snake)) {
                let pLen = getPathLengthToTail({ x: nx, y: ny }, tail, snake);
                if (pLen !== -1 && pLen > maxDistToTail) {
                    maxDistToTail = pLen;
                    bestStallMove = { x: nx, y: ny };
                }
            }
        }
        if (bestStallMove) return bestStallMove;

        // STRATEGY 3: Last resort
        for (let dir of dirs) {
            let nx = head.x + dir.x;
            let ny = head.y + dir.y;
            if (isValid(nx, ny) && !isCollision(nx, ny, snake)) return { x: nx, y: ny };
        }
        return null;
    }

    function getPathLengthToTail(start, target, currentSnake) {
        let queue = [{ pos: start, dist: 0 }];
        let visited = new Set();
        visited.add(`${start.x},${start.y}`);
        while (queue.length > 0) {
            let { pos, dist } = queue.shift();
            if (pos.x === target.x && pos.y === target.y) return dist;
            const dirs = [
                { x: 0, y: -1 }, { x: 0, y: 1 },
                { x: -1, y: 0 }, { x: 1, y: 0 }
            ];
            for (let dir of dirs) {
                let nx = pos.x + dir.x;
                let ny = pos.y + dir.y;
                let key = `${nx},${ny}`;
                if (isValid(nx, ny) && !visited.has(key)) {
                    if (!isCollision(nx, ny, currentSnake) || (nx === target.x && ny === target.y)) {
                        visited.add(key);
                        queue.push({ pos: { x: nx, y: ny }, dist: dist + 1 });
                    }
                }
            }
        }
        return -1;
    }

    // === PARTICLE SYSTEM ===
    function spawnParticles(x, y, color, count) {
        for (let i = 0; i < count; i++) {
            const angle = (Math.PI * 2 / count) * i + Math.random() * 0.5;
            const speed = 1.5 + Math.random() * 3;
            particles.push({
                x: x * BLOCK_SIZE + BLOCK_SIZE / 2,
                y: y * BLOCK_SIZE + BLOCK_SIZE / 2,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life: 1.0,
                decay: 0.02 + Math.random() * 0.03,
                size: 2 + Math.random() * 3,
                color: color
            });
        }
    }

    function updateParticles() {
        pCtx.clearRect(0, 0, pCanvas.width, pCanvas.height);
        particles = particles.filter(p => p.life > 0);
        for (let p of particles) {
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.05; // gravity
            p.life -= p.decay;
            p.vx *= 0.98;

            pCtx.globalAlpha = p.life;
            pCtx.fillStyle = p.color;
            pCtx.shadowColor = p.color;
            pCtx.shadowBlur = 8;
            pCtx.beginPath();
            pCtx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
            pCtx.fill();
        }
        pCtx.globalAlpha = 1;
        pCtx.shadowBlur = 0;
    }

    // === COMBO SYSTEM ===
    function triggerCombo(foodType) {
        combo++;
        if (comboTimer) clearTimeout(comboTimer);
        comboTimer = setTimeout(() => { combo = 0; }, COMBO_TIMEOUT);

        let text = `+${score > 0 ? 10 * Math.min(combo, 5) : 10}`;
        let color = C_FOOD_NORMAL;
        let size = '1rem';

        if (foodType === 'BONUS') {
            text = 'â˜… BONUS â˜…';
            color = C_FOOD_BONUS;
            size = '1.1rem';
        }

        if (combo >= 5) {
            text = `COMBO x${combo}!`;
            color = '#FF44FF';
            size = '1.3rem';
        }

        if (combo >= 10) {
            text = `ðŸ”¥ FIRE x${combo}!`;
            color = '#FF4400';
            size = '1.5rem';
        }

        const el = document.createElement('div');
        el.className = 'combo-text';
        el.textContent = text;
        el.style.color = color;
        el.style.fontSize = size;
        el.style.textShadow = `0 0 20px ${color}`;
        el.style.left = `${Math.random() * 60 + 20}%`;
        el.style.top = `${Math.random() * 30 + 35}%`;
        comboDisplay.appendChild(el);
        setTimeout(() => el.remove(), 1000);
    }

    // === FAKE WASD ===
    function updateWASD(dx, dy) {
        keyW.classList.remove('active');
        keyA.classList.remove('active');
        keyS.classList.remove('active');
        keyD.classList.remove('active');

        if (dy === -1) keyW.classList.add('active');
        else if (dy === 1) keyS.classList.add('active');
        else if (dx === -1) keyA.classList.add('active');
        else if (dx === 1) keyD.classList.add('active');
    }

    // === FOOD SYSTEM ===
    function addFood(type) {
        if (foods.length >= 50) return;
        let valid = false, rx, ry, attempts = 0;
        while (!valid && attempts < 100) {
            rx = Math.floor(Math.random() * COLS);
            ry = Math.floor(Math.random() * ROWS);
            let hitSnake = snake.some(p => p.x === rx && p.y === ry);
            let hitFood = foods.some(f => f.x === rx && f.y === ry);
            if (!hitSnake && !hitFood) valid = true;
            attempts++;
        }
        if (valid) {
            foods.push({ x: rx, y: ry, type: type, age: 0 });
        }
    }

    function spawnFoodLogic() {
        addFood('NORMAL');
        // 8% jackpot chance
        if (Math.random() < 0.08) {
            for (let i = 0; i < 4; i++) addFood('BONUS');
        }
    }

    // === HUD UPDATE ===
    function updateUI() {
        scoreVal.innerText = score;
        lengthVal.innerText = snake.length;
        if (score > highScore) {
            highScore = score;
            localStorage.setItem('snakeHighScore', highScore);
        }
        highScoreVal.innerText = highScore;

        const pct = Math.max(0, 100 - ((movesSinceEat / MAX_MOVES_WITHOUT_EAT) * 100));
        energyFill.style.width = pct + '%';

        if (pct < 20) {
            energyFill.style.background = 'linear-gradient(90deg, #FF0000, #FF3333)';
        } else if (pct < 50) {
            energyFill.style.background = 'linear-gradient(90deg, #FFAA00, #FFDD00)';
        } else {
            energyFill.style.background = 'linear-gradient(90deg, #00FF88, #00FFCC)';
        }

        statGames.innerText = totalGames;
        statEaten.innerText = totalEaten;
        statMax.innerText = maxLength;
    }

    // === GAME ENGINE ===
    function initGame() {
        if (gameInterval) clearInterval(gameInterval);
        snake = [
            { x: Math.floor(COLS / 2), y: Math.floor(ROWS / 2) },
            { x: Math.floor(COLS / 2) - 1, y: Math.floor(ROWS / 2) },
            { x: Math.floor(COLS / 2) - 2, y: Math.floor(ROWS / 2) },
            { x: Math.floor(COLS / 2) - 3, y: Math.floor(ROWS / 2) }
        ];
        foods = [];
        score = 0;
        movesSinceEat = 0;
        combo = 0;
        currentSpeed = BASE_SPEED;
        lastDirection = { x: 1, y: 0 };
        particles = [];
        trailHistory = [];
        totalGames++;

        updateUI();
        uiOverlay.classList.add('hidden');
        addFood('NORMAL');

        isRunning = true;
        gameInterval = setInterval(gameLoop, currentSpeed);
    }

    function gameLoop() {
        if (!isRunning) return;

        movesSinceEat++;
        if (movesSinceEat >= MAX_MOVES_WITHOUT_EAT) {
            gameOver('STARVATION');
            return;
        }
        updateUI();

        let nextMove = decideNextMove();

        if (nextMove) {
            // Track direction for WASD
            const head = snake[0];
            const dx = nextMove.x - head.x;
            const dy = nextMove.y - head.y;
            lastDirection = { x: dx, y: dy };
            updateWASD(dx, dy);

            // Update trail
            trailHistory.unshift({ x: head.x, y: head.y });
            if (trailHistory.length > MAX_TRAIL) trailHistory.pop();

            // Check eaten food
            let ateIdx = foods.findIndex(f => f.x === nextMove.x && f.y === nextMove.y);
            snake.unshift(nextMove);

            if (ateIdx !== -1) {
                let eatenType = foods[ateIdx].type;
                let basePoints = 10;
                let comboMultiplier = Math.min(combo + 1, 5);
                score += basePoints * comboMultiplier;
                foods.splice(ateIdx, 1);
                movesSinceEat = 0;
                totalEaten++;

                // Track max length
                if (snake.length > maxLength) maxLength = snake.length;

                // Particle explosion
                let pColor = eatenType === 'BONUS' ? C_FOOD_BONUS : C_FOOD_NORMAL;
                spawnParticles(nextMove.x, nextMove.y, pColor, eatenType === 'BONUS' ? 20 : 12);

                // Combo text
                triggerCombo(eatenType);

                // Respawn logic
                if (eatenType === 'NORMAL') spawnFoodLogic();

                // Adaptive speed
                currentSpeed = Math.max(MIN_SPEED, BASE_SPEED - snake.length * SPEED_STEP);
                clearInterval(gameInterval);
                gameInterval = setInterval(gameLoop, currentSpeed);
            } else {
                snake.pop();
            }
        } else {
            gameOver('CRASH');
        }

        // Age food (for pulsing effect)
        for (let f of foods) f.age++;

        render();
        updateParticles();
    }

    function gameOver(reason) {
        isRunning = false;
        clearInterval(gameInterval);

        // Screen shake
        gameWrapper.classList.add('shake');
        setTimeout(() => gameWrapper.classList.remove('shake'), 300);

        // Explosion on head
        spawnParticles(snake[0].x, snake[0].y, '#FF0044', 30);

        uiOverlay.classList.remove('hidden');
        overlayTitle.innerText = 'GAME OVER';

        let reasonText = reason === 'STARVATION' ? 'âš¡ OUT OF ENERGY' : 'ðŸ’¥ COLLISION';
        overlaySub.innerHTML = `${reasonText}<br><span style="color:rgba(255,255,255,0.2); font-size:0.6rem">RESTARTING...</span>`;
        startBtn.style.display = 'none';

        // Render particles for a bit
        let renderFrames = 0;
        let deathAnim = setInterval(() => {
            updateParticles();
            renderFrames++;
            if (renderFrames > 30) clearInterval(deathAnim);
        }, 30);

        setTimeout(() => initGame(), 2500);
    }

    // === RENDERING ===
    function lerpColor(a, b, t) {
        const ah = parseInt(a.replace('#', ''), 16);
        const bh = parseInt(b.replace('#', ''), 16);
        const ar = (ah >> 16) & 0xff, ag = (ah >> 8) & 0xff, ab = ah & 0xff;
        const br = (bh >> 16) & 0xff, bg = (bh >> 8) & 0xff, bb = bh & 0xff;
        const rr = Math.round(ar + (br - ar) * t);
        const rg = Math.round(ag + (bg - ag) * t);
        const rb = Math.round(ab + (bb - ab) * t);
        return `rgb(${rr},${rg},${rb})`;
    }

    function render() {
        // Background
        ctx.fillStyle = C_BG;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Grid (subtle dots at intersections)
        ctx.fillStyle = C_GRID;
        for (let i = 0; i <= COLS; i++) {
            for (let j = 0; j <= ROWS; j++) {
                ctx.fillRect(i * BLOCK_SIZE - 0.5, j * BLOCK_SIZE - 0.5, 1, 1);
            }
        }

        // === GLOW TRAIL ===
        for (let i = 0; i < trailHistory.length; i++) {
            const t = trailHistory[i];
            const alpha = (1 - (i / trailHistory.length)) * 0.15;
            const size = BLOCK_SIZE * (1 - (i / trailHistory.length)) * 0.5;
            ctx.fillStyle = `rgba(160, 32, 240, ${alpha})`;
            ctx.shadowColor = '#A020F0';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.arc(
                t.x * BLOCK_SIZE + BLOCK_SIZE / 2,
                t.y * BLOCK_SIZE + BLOCK_SIZE / 2,
                size, 0, Math.PI * 2
            );
            ctx.fill();
        }
        ctx.shadowBlur = 0;

        // === FOOD ===
        const time = Date.now() * 0.003;
        for (let f of foods) {
            const pulse = 1 + Math.sin(time + f.age * 0.3) * 0.15;
            const cx = f.x * BLOCK_SIZE + BLOCK_SIZE / 2;
            const cy = f.y * BLOCK_SIZE + BLOCK_SIZE / 2;
            const radius = (BLOCK_SIZE / 3) * pulse;

            // Outer glow
            const glowColor = f.type === 'BONUS' ? C_FOOD_BONUS : C_FOOD_NORMAL;
            ctx.shadowColor = glowColor;
            ctx.shadowBlur = 15;
            ctx.fillStyle = glowColor;
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, Math.PI * 2);
            ctx.fill();

            // Inner bright core
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#fff';
            ctx.globalAlpha = 0.6;
            ctx.beginPath();
            ctx.arc(cx, cy, radius * 0.35, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }
        ctx.shadowBlur = 0;

        // === SNAKE BODY ===
        // Draw connections first (smooth body)
        for (let i = snake.length - 1; i >= 1; i--) {
            const curr = snake[i];
            const prev = snake[i - 1];
            const t = i / snake.length;
            const color = lerpColor(C_BODY_START, C_BODY_END, t);
            const thickness = BLOCK_SIZE * (0.35 + (1 - t) * 0.15);

            ctx.strokeStyle = color;
            ctx.lineWidth = thickness;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(curr.x * BLOCK_SIZE + BLOCK_SIZE / 2, curr.y * BLOCK_SIZE + BLOCK_SIZE / 2);
            ctx.lineTo(prev.x * BLOCK_SIZE + BLOCK_SIZE / 2, prev.y * BLOCK_SIZE + BLOCK_SIZE / 2);
            ctx.stroke();
        }

        // Draw segment nodes
        for (let i = snake.length - 1; i >= 0; i--) {
            const part = snake[i];
            const cx = part.x * BLOCK_SIZE + BLOCK_SIZE / 2;
            const cy = part.y * BLOCK_SIZE + BLOCK_SIZE / 2;

            if (i === 0) {
                // HEAD â€” White glowing circle
                ctx.shadowColor = '#ffffff';
                ctx.shadowBlur = 20;
                ctx.fillStyle = C_HEAD;
                ctx.beginPath();
                ctx.arc(cx, cy, (BLOCK_SIZE / 2) - 1, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;

                // Eyes
                const dx = lastDirection.x;
                const dy = lastDirection.y;
                const eyeOffset = BLOCK_SIZE * 0.2;
                const eyeSize = BLOCK_SIZE * 0.1;
                const pupilSize = BLOCK_SIZE * 0.06;

                // Eye positions perpendicular to direction
                let e1x, e1y, e2x, e2y;
                if (dx !== 0) {
                    e1x = cx + dx * eyeOffset * 0.5;
                    e1y = cy - eyeOffset;
                    e2x = cx + dx * eyeOffset * 0.5;
                    e2y = cy + eyeOffset;
                } else {
                    e1x = cx - eyeOffset;
                    e1y = cy + dy * eyeOffset * 0.5;
                    e2x = cx + eyeOffset;
                    e2y = cy + dy * eyeOffset * 0.5;
                }

                // Eyeball
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(e1x, e1y, eyeSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(e2x, e2y, eyeSize, 0, Math.PI * 2);
                ctx.fill();

                // Pupil
                ctx.fillStyle = '#A020F0';
                ctx.beginPath();
                ctx.arc(e1x + dx * pupilSize, e1y + dy * pupilSize, pupilSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(e2x + dx * pupilSize, e2y + dy * pupilSize, pupilSize, 0, Math.PI * 2);
                ctx.fill();

            } else if (i === snake.length - 1) {
                // TAIL â€” Fading triangular
                const t = 1;
                const tailSize = BLOCK_SIZE * 0.25;
                ctx.fillStyle = C_TAIL;
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.arc(cx, cy, tailSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }
    }

    // === INIT ===
    startBtn.addEventListener('click', initGame);

    // Also allow tap anywhere to start
    gameWrapper.addEventListener('click', (e) => {
        if (!isRunning && e.target !== startBtn) initGame();
    });

    render();

    // === GENERATE PWA ICONS ===
    function generateIcon(size) {
        const c = document.createElement('canvas');
        c.width = size;
        c.height = size;
        const x = c.getContext('2d');

        // Background
        x.fillStyle = '#0d0d0d';
        x.fillRect(0, 0, size, size);

        // Border ring
        const margin = size * 0.08;
        x.strokeStyle = '#A020F0';
        x.lineWidth = size * 0.02;
        x.shadowColor = '#A020F0';
        x.shadowBlur = size * 0.05;
        x.beginPath();
        x.roundRect(margin, margin, size - margin * 2, size - margin * 2, size * 0.15);
        x.stroke();
        x.shadowBlur = 0;

        // Snake body
        const points = [
            [0.3, 0.75], [0.3, 0.45], [0.5, 0.55],
            [0.7, 0.35], [0.7, 0.55]
        ];
        x.strokeStyle = '#A020F0';
        x.lineWidth = size * 0.07;
        x.lineCap = 'round';
        x.lineJoin = 'round';
        x.shadowColor = '#A020F0';
        x.shadowBlur = size * 0.1;
        x.beginPath();
        x.moveTo(points[0][0] * size, points[0][1] * size);
        for (let i = 1; i < points.length; i++) {
            x.lineTo(points[i][0] * size, points[i][1] * size);
        }
        x.stroke();

        // Head
        x.shadowBlur = size * 0.08;
        x.shadowColor = '#fff';
        x.fillStyle = '#fff';
        x.beginPath();
        x.arc(points[points.length - 1][0] * size, points[points.length - 1][1] * size, size * 0.05, 0, Math.PI * 2);
        x.fill();

        // Food dot
        x.shadowColor = '#00FFCC';
        x.shadowBlur = size * 0.06;
        x.fillStyle = '#00FFCC';
        x.beginPath();
        x.arc(0.42 * size, 0.72 * size, size * 0.035, 0, Math.PI * 2);
        x.fill();

        return c.toDataURL('image/png');
    }

    // Save icons for PWA
    function saveIconToDisk(dataUrl, filename) {
        // Create link element to save icon â€” handled by service worker cache
        const link = document.createElement('link');
        link.rel = 'icon';
        link.href = dataUrl;
        link.sizes = filename.includes('192') ? '192x192' : '512x512';
        document.head.appendChild(link);
    }

    // Generate and apply icons
    const icon192 = generateIcon(192);
    const icon512 = generateIcon(512);
    saveIconToDisk(icon192, 'icon-192');
    saveIconToDisk(icon512, 'icon-512');

    // Apple touch icon
    const appleTouchIcon = document.createElement('link');
    appleTouchIcon.rel = 'apple-touch-icon';
    appleTouchIcon.href = icon192;
    document.head.appendChild(appleTouchIcon);

</script>
</body>
</html>